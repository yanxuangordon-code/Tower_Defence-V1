<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tower Defense ‚Äì üè∞üî•‚ùÑÔ∏èüí• Ultimate Defense!</title>
<style>
:root {
  --bg: #0f172a;
  --card: #1e293b;
  --text: #f1f5f9;
  --accent: #38bdf8;
  --danger: #f87171;
  --success: #4ade80;
  --warning: #fbbf24;
  --energy: #8b5cf6;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: 'Segoe UI', system-ui, sans-serif;
  text-align: center;
  padding: 10px;
  min-height: 100vh;
}

h1 {
  margin: 10px 0 15px;
  font-weight: 800;
  font-size: 2rem;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
  background: linear-gradient(90deg, #38bdf8, #8b5cf6, #fbbf24);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

#container {
  max-width: 900px;
  margin: 0 auto;
}

#menu, #game-over {
  padding: 20px;
  background: var(--card);
  border-radius: 12px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
}

#menu h2, #game-over h2 {
  margin-top: 0;
  font-size: 1.8rem;
  color: var(--accent);
}

button {
  padding: 12px 16px;
  margin: 6px 4px;
  background: #334155;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s;
  min-width: 90px;
  white-space: nowrap;
}

button:hover:not(:disabled) {
  background: #475569;
  transform: translateY(-2px);
}

button:active {
  transform: translateY(0);
}

button.selected {
  background: var(--accent);
  color: #0f172a;
  box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.4);
}

button.danger {
  background: var(--danger);
}

button.energy {
  background: var(--energy);
  display: flex;
  align-items: center;
  gap: 4px;
}

#ui {
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
  gap: 6px;
  margin: 12px 0;
  padding: 10px;
  background: #1e293b;
  border-radius: 10px;
  font-weight: 600;
  font-size: 0.95rem;
}

.stat { display: flex; align-items: center; gap: 4px; }
.stat span { font-weight: bold; }

#shop, #abilities {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
  margin: 10px 0;
}

canvas {
  background: #0f172a;
  display: block;
  margin: 10px auto;
  border-radius: 8px;
  box-shadow: 0 6px 16px rgba(0,0,0,0.5);
  max-width: 100%;
  height: auto;
}

#instructions {
  margin-top: 10px;
  font-size: 0.85rem;
  color: #94a3b8;
}

@media (max-width: 600px) {
  h1 { font-size: 1.6rem; }
  button { padding: 8px 12px; font-size: 12px; }
  .stat { font-size: 0.8rem; }
  #ui { gap: 4px; }
}
</style>
</head>
<body>
<div id="container">
  <h1>üè∞ Tower Defense ‚Äì Ultimate Defense!</h1>

  <!-- MENU -->
  <div id="menu">
    <h2>Select Difficulty</h2>
    <button onclick="startGame('easy')">üòÄ Easy</button>
    <button onclick="startGame('normal')">üôÇ Normal</button>
    <button onclick="startGame('hard')">üò† Hard</button>
    <p id="instructions">Place towers by clicking. Use <strong>Freeze (E)</strong> or <strong>Missile (R)</strong>!</p>
  </div>

  <!-- UI -->
  <div id="ui" style="display:none;">
    <div class="stat">‚ù§Ô∏è <span id="health">10</span></div>
    <div class="stat">üí∞ <span id="money">100</span></div>
    <div class="stat">‚ö° <span id="energy">0</span>/100</div>
    <div class="stat">üåä Wave <span id="wave">1</span></div>
    <div class="stat">‚≠ê <span id="score">0</span></div>
  </div>

  <!-- SHOP -->
  <div id="shop" style="display:none;"></div>
  
  <!-- ABILITIES -->
  <div id="abilities" style="display:none;"></div>

  <canvas id="game" width="800" height="400"></canvas>

  <!-- GAME OVER -->
  <div id="game-over" style="display:none;">
    <h2>üíÄ Game Over!</h2>
    <p>Final Score: <strong id="final-score">0</strong></p>
    <p>Survived <strong id="final-wave">0</strong> waves.</p>
    <button onclick="restartGame()">üîÅ Play Again</button>
  </div>
</div>

<script>
// ====== CANVAS SETUP (FIXED FOR Hi-DPI) ======
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// Critical: Handle device pixel ratio
let dpr = window.devicePixelRatio || 1;
let width = 800;
let height = 400;

function resizeCanvas() {
  const container = canvas.parentElement;
  const maxWidth = Math.min(container.clientWidth, 850);
  width = maxWidth;
  height = Math.round(width * 0.5); // 2:1 aspect ratio

  // Set actual pixel buffer size (for sharp rendering)
  canvas.width = width * dpr;
  canvas.height = height * dpr;

  // Set CSS display size
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';

  // Scale drawing context
  ctx.scale(dpr, dpr);
}

// Run on load and resize
window.addEventListener('load', resizeCanvas);
window.addEventListener('resize', resizeCanvas);
resizeCanvas(); // Initial setup

// ====== GAME STATE ======
let health = 10, money = 100, wave = 1, score = 0, energy = 0;
let selectedTower = null;
let enemiesToSpawn = 0;
let spawnCooldown = 0;
let gameRunning = false;
let freezeCooldown = 0;
let missileCooldown = 0;

// Difficulty modifiers
let hpMult = 1, speedMult = 1, spawnRateMult = 1;

// Collections
const enemies = [];
const towers = [];
const bullets = [];
const particles = [];
const aoeEffects = [];

// ====== PATH (DYNAMIC, USES `width`) ======
const path = [
  { x: 0, y: 80 },
  { x: Math.min(250, width * 0.3), y: 80 },
  { x: Math.min(250, width * 0.3), y: Math.min(300, height * 0.75) },
  { x: Math.min(550, width * 0.7), y: Math.min(300, height * 0.75) },
  { x: Math.min(550, width * 0.7), y: Math.min(150, height * 0.4) },
  { x: width, y: Math.min(150, height * 0.4) } // ‚Üê DYNAMIC ENDPOINT!
];

// Path collision helper
function isOnPath(x, y) {
  const pathWidth = 40;
  for (let i = 0; i < path.length - 1; i++) {
    const p1 = path[i], p2 = path[i+1];
    const dist = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
    if (dist <= pathWidth/2 + 15) return true;
  }
  return false;
}

function distToSegment(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  if (lenSq !== 0) param = dot / lenSq;
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  const dx = px - xx, dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

// ====== CLASSES ======
class Particle {
  constructor(x, y, color = '#ffffff', size = 3, vx = 0, vy = 0, life = 30) {
    this.x = x;
    this.y = y;
    this.vx = vx || (Math.random() - 0.5) * 4;
    this.vy = vy || (Math.random() - 0.5) * 4 - 1;
    this.life = life;
    this.maxLife = life;
    this.color = color;
    this.size = size + Math.random() * 2;
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.1;
    this.life--;
    return this.life <= 0;
  }
  draw() {
    const alpha = this.life / this.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

class Enemy {
  constructor(type, wave) {
    this.type = type;
    this.x = path[0].x;
    this.y = path[0].y;
    this.targetIndex = 1;
    this.wave = wave;
    this.slow = 1;

    if (type === "normal") {
      this.hp = (5 + wave * 0.5) * hpMult;
      this.speed = 1 * speedMult;
      this.color = "#ef4444";
      this.reward = 10;
      this.score = 10;
    } else if (type === "fast") {
      this.hp = (3 + wave * 0.3) * hpMult;
      this.speed = 1.8 * speedMult;
      this.color = "#06b6d4";
      this.reward = 12;
      this.score = 15;
    } else if (type === "strong") {
      this.hp = (12 + wave * 1.2) * hpMult;
      this.speed = 0.6 * speedMult;
      this.color = "#8b5cf6";
      this.reward = 20;
      this.score = 25;
    } else if (type === "boss") {
      this.hp = (80 + wave * 8) * hpMult;
      this.speed = 0.4 * speedMult;
      this.color = "#fbbf24";
      this.reward = 100;
      this.score = 200;
      this.size = 32;
    }
    this.maxHp = this.hp;
    this.size = this.type === "boss" ? 32 : 20;
    this.effects = [];
  }

  update() {
    for (let i = this.effects.length - 1; i >= 0; i--) {
      const eff = this.effects[i];
      if (eff.type === 'burn') {
        this.hp -= eff.dps / 60;
      }
      eff.duration--;
      if (eff.duration <= 0) this.effects.splice(i, 1);
    }

    const target = path[this.targetIndex];
    if (!target) {
      health--;
      return true;
    }

    const dx = target.x - this.x;
    const dy = target.y - this.y;
    const dist = Math.hypot(dx, dy);
    const speed = this.speed * this.slow;

    if (dist < speed) {
      this.x = target.x;
      this.y = target.y;
      this.targetIndex++;
    } else {
      this.x += (dx / dist) * speed;
      this.y += (dy / dist) * speed;
    }

    if (this.slow < 1) {
      this.slow += 0.02;
      if (this.slow > 1) this.slow = 1;
    }

    return false;
  }

  draw() {
    const barWidth = this.size;
    const healthPercent = Math.max(0, this.hp / this.maxHp);
    ctx.fillStyle = '#334155';
    ctx.fillRect(this.x - barWidth/2, this.y - this.size/2 - 10, barWidth, 4);
    ctx.fillStyle = '#10b981';
    ctx.fillRect(this.x - barWidth/2, this.y - this.size/2 - 10, barWidth * healthPercent, 4);

    if (this.effects.some(e => e.type === 'burn')) {
      ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size/2 + 3, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = '#0f172a';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  applySlow(mult) {
    this.slow = Math.min(this.slow, mult);
  }

  applyBurn(dps, duration) {
    this.effects.push({ type: 'burn', duration, dps });
  }
}

class Tower {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.cooldown = 0;

    switch(type) {
      case "basic":
        this.range = 100;
        this.cooldownMax = 30;
        this.damage = 1;
        this.color = "#3b82f6";
        this.name = "Basic";
        break;
      case "fast":
        this.range = 90;
        this.cooldownMax = 15;
        this.damage = 1;
        this.color = "#10b981";
        this.name = "Fast";
        break;
      case "sniper":
        this.range = 240;
        this.cooldownMax = 60;
        this.damage = 4;
        this.color = "#f59e0b";
        this.name = "Sniper";
        break;
      case "frozen":
        this.range = 120;
        this.cooldownMax = 25;
        this.damage = 0.5;
        this.slowMult = 0.4;
        this.color = "#93c5fd";
        this.name = "Frozen";
        break;
      case "flame":
        this.range = 80;
        this.cooldownMax = 4;
        this.dps = 0.8;
        this.color = "#f87171";
        this.name = "Flame";
        break;
      case "lazer":
        this.range = 200;
        this.cooldownMax = 4;
        this.damage = 0.6;
        this.pierce = 3;
        this.color = "#ec4899";
        this.name = "Lazer";
        break;
      case "missile":
        this.range = 180;
        this.cooldownMax = 45;
        this.damage = 8;
        this.splash = 40;
        this.color = "#8b5cf6";
        this.name = "Missile";
        break;
    }
  }

  update() {
    if (this.cooldown > 0) {
      this.cooldown--;
      return;
    }

    switch(this.type) {
      case "basic":
      case "fast":
      case "sniper":
        this.shootSingle();
        break;
      case "frozen":
        this.shootFrozen();
        break;
      case "flame":
        this.shootFlame();
        break;
      case "lazer":
        this.shootLazer();
        break;
      case "missile":
        this.shootMissile();
        break;
    }
  }

  shootSingle() {
    let closest = null;
    let closestDist = Infinity;
    for (const e of enemies) {
      const d = Math.hypot(e.x - this.x, e.y - this.y);
      if (d <= this.range && d < closestDist) {
        closestDist = d;
        closest = e;
      }
    }
    if (closest) {
      bullets.push(new Bullet(this.x, this.y, closest, this.damage, this.type));
      this.cooldown = this.cooldownMax;
    }
  }

  shootFrozen() {
    const targets = enemies.filter(e => 
      Math.hypot(e.x - this.x, e.y - this.y) <= this.range
    ).slice(0, 1);

    for (const e of targets) {
      e.hp -= this.damage;
      e.applySlow(this.slowMult);
      for (let i = 0; i < 5; i++) {
        particles.push(new Particle(e.x, e.y, '#dbeafe', 1.5, (Math.random()-0.5)*3, (Math.random()-0.5)*3, 30));
      }
    }
    if (targets.length > 0) this.cooldown = this.cooldownMax;
  }

  shootFlame() {
    const targets = enemies.filter(e => 
      Math.hypot(e.x - this.x, e.y - this.y) <= this.range
    );
    for (const e of targets) {
      e.applyBurn(this.dps, 120);
      const angle = Math.atan2(e.y - this.y, e.x - this.x);
      for (let i = 0; i < 3; i++) {
        const dist = 10 + i * 15;
        particles.push(new Particle(
          this.x + Math.cos(angle) * dist,
          this.y + Math.sin(angle) * dist,
          '#f87171', 2, 0, 0, 15
        ));
      }
    }
    if (targets.length > 0) this.cooldown = this.cooldownMax;
  }

  shootLazer() {
    let primary = null;
    let minDist = Infinity;
    for (const e of enemies) {
      const d = Math.hypot(e.x - this.x, e.y - this.y);
      if (d <= this.range && d < minDist) {
        minDist = d;
        primary = e;
      }
    }
    if (!primary) return;

    const angle = Math.atan2(primary.y - this.y, primary.x - this.x);
    const hits = [];

    for (const e of enemies) {
      const d = Math.hypot(e.x - this.x, e.y - this.y);
      if (d > this.range) continue;
      const a2 = Math.atan2(e.y - this.y, e.x - this.x);
      const diff = Math.abs(a2 - angle);
      if (diff < 0.15) {
        hits.push({ enemy: e, dist: d });
      }
    }

    hits.sort((a, b) => a.dist - b.dist);
    const actualHits = hits.slice(0, this.pierce);

    if (actualHits.length > 0) {
      const last = actualHits[actualHits.length - 1].enemy;
      ctx.strokeStyle = '#ec4899';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(last.x, last.y);
      ctx.stroke();

      ctx.strokeStyle = '#f472b640';
      ctx.lineWidth = 8;
      ctx.stroke();

      for (const h of actualHits) {
        h.enemy.hp -= this.damage;
      }
      this.cooldown = this.cooldownMax;
    }
  }

  shootMissile() {
    let closest = null;
    let closestDist = Infinity;
    for (const e of enemies) {
      const d = Math.hypot(e.x - this.x, e.y - this.y);
      if (d <= this.range && d < closestDist) {
        closestDist = d;
        closest = e;
      }
    }
    if (closest) {
      bullets.push(new Bullet(this.x, this.y, closest, this.damage, this.type, this.splash));
      this.cooldown = this.cooldownMax;
    }
  }

  draw() {
    if (selectedTower === this.type) {
      ctx.strokeStyle = this.color + '30';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.fillStyle = '#64748b';
    ctx.beginPath();
    ctx.arc(this.x, this.y, 14, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'white';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(this.name[0], this.x, this.y + 4);
    ctx.textAlign = 'left';
  }
}

class Bullet {
  constructor(x, y, target, damage, towerType, splash = 0) {
    this.x = x;
    this.y = y;
    this.target = target;
    this.damage = damage;
    this.towerType = towerType;
    this.splash = splash;
    this.speed = towerType === 'sniper' ? 8 : 
                towerType === 'missile' ? 5 : 4;
    this.hit = false;
  }

  update() {
    if (!this.target || this.target.hp <= 0) return true;

    const dx = this.target.x - this.x;
    const dy = this.target.y - this.y;
    const dist = Math.hypot(dx, dy);

    if (dist < 5) {
      if (!this.hit) {
        this.target.hp -= this.damage;
        this.hit = true;

        if (this.splash > 0) {
          for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 3;
            particles.push(new Particle(
              this.x, this.y,
              '#fbbf24', 2,
              Math.cos(angle) * speed,
              Math.sin(angle) * speed,
              30
            ));
          }
          for (const e of enemies) {
            const d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d <= this.splash && e !== this.target) {
              e.hp -= this.damage * 0.6;
            }
          }
          aoeEffects.push({
            x: this.x, y: this.y, radius: this.splash,
            color: '#fbbf2440', life: 20, type: 'explosion'
          });
        } else {
          for (let i = 0; i < 3; i++) {
            particles.push(new Particle(this.x, this.y, 
              this.towerType === 'sniper' ? '#f59e0b' : '#e2e8f0'
            ));
          }
        }
      }
      return true;
    }

    this.x += (dx / dist) * this.speed;
    this.y += (dy / dist) * this.speed;
    return false;
  }

  draw() {
    if (this.towerType === 'missile') {
      ctx.fillStyle = '#8b5cf6';
      ctx.beginPath();
      ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
      ctx.fill();
      particles.push(new Particle(this.x, this.y, '#c084fc', 1.5, 0, 0, 10));
    } else {
      ctx.fillStyle = this.towerType === 'sniper' ? '#f59e0b' : '#e2e8f0';
      ctx.beginPath();
      ctx.arc(this.x, this.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

class AoeEffect {
  constructor(x, y, radius, color, life, type) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.color = color;
    this.life = life;
    this.maxLife = life;
    this.type = type;
  }
  update() {
    this.life--;
    return this.life <= 0;
  }
  draw() {
    const alpha = this.life / this.maxLife;
    const hexAlpha = Math.floor(alpha * 255).toString(16).padStart(2, '0');
    ctx.fillStyle = this.color.slice(0, -2) + hexAlpha;
    if (this.type === 'explosion') {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius * (1.5 - 0.5 * alpha), 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// ====== UI & GAME CONTROL ======
function initShop() {
  const shop = document.getElementById('shop');
  shop.innerHTML = `
    <button data-cost="50" onclick="selectTower('basic', this)">Basic (50)</button>
    <button data-cost="75" onclick="selectTower('fast', this)">Fast (75)</button>
    <button data-cost="120" onclick="selectTower('sniper', this)">Sniper (120)</button>
    <button data-cost="150" onclick="selectTower('frozen', this)">Frozen (150)</button>
    <button data-cost="130" onclick="selectTower('flame', this)">Flame (130)</button>
    <button data-cost="200" onclick="selectTower('lazer', this)">Lazer (200)</button>
    <button data-cost="250" onclick="selectTower('missile', this)">Missile (250)</button>
  `;
}

function initAbilities() {
  const abilities = document.getElementById('abilities');
  abilities.innerHTML = `
    <button id="btn-freeze" class="energy" onclick="useFreeze()" ${freezeCooldown > 0 ? 'disabled' : ''}>
      ‚ùÑÔ∏è Freeze (${freezeCooldown > 0 ? Math.ceil(freezeCooldown/60) + 's' : 'READY'})
    </button>
    <button id="btn-missile" class="energy" onclick="useMissile()" ${missileCooldown > 0 ? 'disabled' : ''}>
      üí• Missile (${missileCooldown > 0 ? Math.ceil(missileCooldown/60) + 's' : 'READY'})
    </button>
  `;
}

function selectTower(type, btn) {
  selectedTower = type;
  document.querySelectorAll("#shop button").forEach(b => b.classList.remove("selected"));
  btn.classList.add("selected");
}

function gainEnergy(amount) {
  energy = Math.min(100, energy + amount);
  document.getElementById("energy").textContent = Math.floor(energy);
}

function useFreeze() {
  if (freezeCooldown > 0 || energy < 30) return;
  freezeCooldown = 300;
  energy -= 30;
  updateUI();

  for (const e of enemies) {
    e.applySlow(0.3);
  }

  for (let i = 0; i < 50; i++) {
    const x = Math.random() * width;
    const y = Math.random() * height;
    particles.push(new Particle(x, y, '#93c5fd', 1.5, 0, 0, 40));
  }
}

function useMissile() {
  if (missileCooldown > 0 || energy < 50) return;
  missileCooldown = 420;
  energy -= 50;
  updateUI();

  for (let i = 0; i < 3; i++) {
    const e = enemies[Math.floor(Math.random() * enemies.length)];
    if (!e) continue;
    const x = e.x + (Math.random() - 0.5) * 60;
    const y = e.y + (Math.random() - 0.5) * 60;

    for (const en of enemies) {
      const d = Math.hypot(en.x - x, en.y - y);
      if (d <= 60) {
        en.hp -= 12;
      }
    }

    for (let p = 0; p < 30; p++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 1 + Math.random() * 4;
      particles.push(new Particle(x, y, '#fbbf24', 3, Math.cos(angle)*speed, Math.sin(angle)*speed, 40));
    }
    aoeEffects.push(new AoeEffect(x, y, 60, '#fbbf2460', 30, 'explosion'));
  }
}

canvas.addEventListener("click", e => {
  if (!selectedTower || !gameRunning) return;

  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width) / dpr;
  const y = (e.clientY - rect.top) * (canvas.height / rect.height) / dpr;

  const cost = { basic:50, fast:75, sniper:120, frozen:150, flame:130, lazer:200, missile:250 };
  if (money < cost[selectedTower]) return;

  if (x < 20 || x > width - 20 || y < 20 || y > height - 20 || isOnPath(x, y)) return;

  for (const t of towers) {
    if (Math.hypot(t.x - x, t.y - y) < 30) return;
  }

  towers.push(new Tower(x, y, selectedTower));
  money -= cost[selectedTower];
  updateUI();
});

document.addEventListener('keydown', e => {
  if (!gameRunning) return;
  if (e.key === 'e' || e.key === 'E') useFreeze();
  if (e.key === 'r' || e.key === 'R') useMissile();
});

function randomEnemyType(wave) {
  if (wave <= 3) return "normal";
  const r = Math.random();
  if (wave <= 10) {
    if (r < 0.6) return "normal";
    if (r < 0.85) return "fast";
    return "strong";
  } else {
    if (r < 0.4) return "normal";
    if (r < 0.65) return "fast";
    if (r < 0.85) return "strong";
    return Math.random() < 0.3 ? "boss" : "strong";
  }
}

function startWave() {
  enemiesToSpawn = wave % 5 === 0 ? 1 : Math.min(35, 5 + Math.floor(wave * 1.3));
  spawnCooldown = 90;
}

let feedback = { text: "", type: "", time: 0 };
function showFeedback(text, type = "info") {
  feedback = { text, type, time: 120 };
}

function drawFeedback() {
  if (feedback.time <= 0) return;
  feedback.time--;
  
  ctx.font = "16px Arial";
  const metrics = ctx.measureText(feedback.text);
  const x = width/2 - metrics.width/2;
  const y = height - 50;
  
  ctx.fillStyle = feedback.type === "error" ? '#f8717180' : 
                 feedback.type === "success" ? '#4ade8080' : '#8b5cf680';
  ctx.fillRect(x - 10, y - 20, metrics.width + 20, 30);
  
  ctx.fillStyle = 'white';
  ctx.fillText(feedback.text, x, y);
}

function updateUI() {
  document.getElementById("health").textContent = Math.max(0, health);
  document.getElementById("money").textContent = money;
  document.getElementById("energy").textContent = Math.floor(energy);
  document.getElementById("wave").textContent = wave;
  document.getElementById("score").textContent = score;
  
  const freezeBtn = document.getElementById("btn-freeze");
  const missileBtn = document.getElementById("btn-missile");
  if (freezeBtn) {
    freezeBtn.disabled = freezeCooldown > 0 || energy < 30;
    freezeBtn.innerHTML = `‚ùÑÔ∏è Freeze (${freezeCooldown > 0 ? Math.ceil(freezeCooldown/60) : energy < 30 ? '30‚ö°' : 'READY'})`;
  }
  if (missileBtn) {
    missileBtn.disabled = missileCooldown > 0 || energy < 50;
    missileBtn.innerHTML = `üí• Missile (${missileCooldown > 0 ? Math.ceil(missileCooldown/60) : energy < 50 ? '50‚ö°' : 'READY'})`;
  }
}

function gameLoop() {
  if (!gameRunning) return;

  const grad = ctx.createLinearGradient(0, 0, 0, height);
  grad.addColorStop(0, "#0f172a");
  grad.addColorStop(1, "#1e293b");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, width, height);

  // Draw path (FIXED: uses dynamic coordinates)
  ctx.strokeStyle = "#334155";
  ctx.lineWidth = 40;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for (let i = 1; i < path.length; i++) {
    ctx.lineTo(path[i].x, path[i].y);
  }
  ctx.stroke();

  // Draw path arrows
  ctx.fillStyle = "#64748b";
  ctx.font = "16px Arial";
  for (let i = 0; i < path.length - 1; i++) {
    const p1 = path[i], p2 = path[i+1];
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const len = Math.hypot(dx, dy);
    const steps = Math.floor(len / 80);
    for (let s = 1; s <= steps; s++) {
      const x = p1.x + dx * (s/steps);
      const y = p1.y + dy * (s/steps);
      ctx.fillText("‚Üí", x - 6, y + 6);
    }
  }

  // Spawn enemies
  if (enemiesToSpawn > 0 && spawnCooldown <= 0) {
    const type = wave % 5 === 0 ? "boss" : randomEnemyType(wave);
    enemies.push(new Enemy(type, wave));
    enemiesToSpawn--;
    spawnCooldown = Math.max(10, 40 / spawnRateMult);
  }
  if (spawnCooldown > 0) spawnCooldown--;

  // Update enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    if (enemies[i].update()) {
      enemies.splice(i, 1);
      continue;
    }
    if (enemies[i].hp <= 0) {
      score += enemies[i].score;
      money += enemies[i].reward;
      gainEnergy(enemies[i].type === 'boss' ? 15 : 5);
      for (let p = 0; p < 15; p++) {
        particles.push(new Particle(enemies[i].x, enemies[i].y, enemies[i].color));
      }
      enemies.splice(i, 1);
      updateUI();
      continue;
    }
    enemies[i].draw();
  }

  // Towers, bullets, particles, AoE
  towers.forEach(t => { t.update(); t.draw(); });
  for (let i = bullets.length - 1; i >= 0; i--) {
    if (bullets[i].update()) bullets.splice(i, 1);
    else bullets[i].draw();
  }
  for (let i = particles.length - 1; i >= 0; i--) {
    if (particles[i].update()) particles.splice(i, 1);
    else particles[i].draw();
  }
  for (let i = aoeEffects.length - 1; i >= 0; i--) {
    if (aoeEffects[i].update()) aoeEffects.splice(i, 1);
    else aoeEffects[i].draw();
  }

  // Cooldowns
  if (freezeCooldown > 0) freezeCooldown--;
  if (missileCooldown > 0) missileCooldown--;

  // Next wave
  if (enemies.length === 0 && enemiesToSpawn === 0) {
    wave++;
    startWave();
    updateUI();
  }

  drawFeedback();

  // Game over
  if (health <= 0) {
    gameRunning = false;
    document.getElementById("final-score").textContent = score;
    document.getElementById("final-wave").textContent = wave - 1;
    document.getElementById("ui").style.display = "none";
    document.getElementById("shop").style.display = "none";
    document.getElementById("abilities").style.display = "none";
    document.getElementById("game-over").style.display = "block";
    ctx.fillStyle = "#f87171";
    ctx.font = "bold 48px Arial";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", width/2, height/2 - 20);
    ctx.font = "24px Arial";
    ctx.fillStyle = "#f1f5f9";
    ctx.fillText(`Final Score: ${score}`, width/2, height/2 + 20);
    return;
  }

  requestAnimationFrame(gameLoop);
}

function startGame(difficulty) {
  health = difficulty === "easy" ? 25 : difficulty === "normal" ? 20 : 15;
  money = difficulty === "easy" ? 250 : difficulty === "normal" ? 200 : 150;
  hpMult = difficulty === "easy" ? 0.6 : difficulty === "normal" ? 1 : 1.5;
  speedMult = difficulty === "easy" ? 0.75 : difficulty === "normal" ? 1 : 1.4;
  spawnRateMult = difficulty === "easy" ? 1.5 : difficulty === "normal" ? 1 : 0.6;

  enemies.length = 0;
  towers.length = 0;
  bullets.length = 0;
  particles.length = 0;
  aoeEffects.length = 0;
  wave = 1; score = 0; energy = 0;
  freezeCooldown = 0; missileCooldown = 0;
  selectedTower = null;

  document.getElementById("menu").style.display = "none";
  document.getElementById("ui").style.display = "flex";
  document.getElementById("game-over").style.display = "none";
  canvas.style.display = "block";
  initShop();
  initAbilities();
  document.getElementById("shop").style.display = "flex";
  document.getElementById("abilities").style.display = "flex";

  updateUI();
  startWave();
  gameRunning = true;
  requestAnimationFrame(gameLoop);
}

function restartGame() {
  startGame('normal');
}

// Initialize shop on load
window.addEventListener('load', () => {
  initShop();
  initAbilities();
});
</script>
</body>
</html>
