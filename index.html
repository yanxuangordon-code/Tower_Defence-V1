<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tower Defense ‚Äì üè∞üî•‚ùÑÔ∏èüí• Ultimate Defense!</title>
<style>
:root {
  --bg: #0f172a;
  --card: #1e293b;
  --text: #f1f5f9;
  --accent: #38bdf8;
  --danger: #f87171;
  --success: #4ade80;
  --warning: #fbbf24;
  --energy: #8b5cf6;
  --editor: #e2e8f0;
  --upgrade: #f0abfc;
  --gold: gold;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: 'Segoe UI', system-ui, sans-serif;
  text-align: center;
  padding: 10px;
  min-height: 100vh;
}

h1 {
  margin: 10px 0 5px;
  font-weight: 800;
  font-size: 2rem;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
  background: linear-gradient(90deg, #38bdf8, #8b5cf6, #fbbf24);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

#editor-credit {
  font-size: 0.9rem;
  color: var(--editor);
  margin-bottom: 15px;
  font-style: italic;
}

#container {
  max-width: 900px;
  margin: 0 auto;
}

#menu, #game-over, #leaderboard {
  padding: 20px;
  background: var(--card);
  border-radius: 12px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
  margin-bottom: 15px;
}

/* üîë CRITICAL: Ensure menu is always on top when shown */
#menu.active {
  display: block !important;
  position: relative;
  z-index: 100;
}

#menu h2, #game-over h2, #leaderboard h2 {
  margin-top: 0;
  font-size: 1.8rem;
  color: var(--accent);
}

button {
  padding: 12px 16px;
  margin: 6px 4px;
  background: #334155;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s;
  min-width: 90px;
  white-space: nowrap;
  position: relative;
  z-index: 1;
}

button:hover:not(:disabled) {
  background: #475569;
  transform: translateY(-2px);
}

button:active {
  transform: translateY(0);
  background: #cbd5e1 !important;
}

button.selected {
  background: var(--accent);
  color: #0f172a;
  box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.4);
}

button.danger {
  background: var(--danger);
}

button.energy {
  background: var(--energy);
  display: flex;
  align-items: center;
  gap: 4px;
}

#ui {
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
  gap: 6px;
  margin: 12px 0;
  padding: 10px;
  background: #1e293b;
  border-radius: 10px;
  font-weight: 600;
  font-size: 0.95rem;
}

.stat { display: flex; align-items: center; gap: 4px; }
.stat span { font-weight: bold; }

#shop, #abilities {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
  margin: 10px 0;
}

canvas {
  background: #0f172a;
  display: block;
  margin: 10px auto;
  border-radius: 8px;
  box-shadow: 0 6px 16px rgba(0,0,0,0.5);
  max-width: 100%;
  height: auto;
}

#instructions {
  margin-top: 10px;
  font-size: 0.85rem;
  color: #94a3b8;
}

.leaderboard-item {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid #334155;
}
.leaderboard-item:first-child {
  font-weight: bold;
  color: gold;
}
.leaderboard-item:nth-child(2) {
  color: silver;
}
.leaderboard-item:nth-child(3) {
  color: #cd7f32;
}

/* ====== AUTH MODAL ====== */
#auth-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.auth-panel {
  background: var(--card);
  padding: 25px;
  border-radius: 12px;
  width: 90%;
  max-width: 400px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  text-align: left;
}

.auth-panel h3 {
  margin-top: 0;
  color: var(--accent);
  text-align: center;
}

.auth-panel input {
  width: 100%;
  padding: 12px;
  margin: 8px 0;
  border-radius: 8px;
  border: 1px solid #475569;
  background: #0f172a;
  color: white;
  font-size: 16px;
}

.auth-error {
  color: var(--danger);
  font-size: 14px;
  min-height: 18px;
  margin-top: 6px;
}

.btn-row {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

/* TOOLTIPS */
button[title] {
  position: relative;
}
button[title]:hover::after {
  content: attr(title);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: var(--card);
  padding: 6px 10px;
  border-radius: 6px;
  white-space: pre;
  font-size: 12px;
  z-index: 10;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  pointer-events: none;
}

/* UPGRADE PANEL */
#upgrade-panel {
  display: none;
  flex-direction: column;
  gap: 10px;
  margin-top: 10px;
}

.upgrade-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #334155;
  padding: 8px 12px;
  border-radius: 6px;
}

.upgrade-row button {
  min-width: 100px;
}

.upgrade-title {
  font-weight: bold;
  color: var(--upgrade);
}

/* TABS */
.tabs {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin: 10px 0;
}

.tab {
  padding: 8px 16px;
  background: #334155;
  border: none;
  border-radius: 6px;
  color: var(--text);
  cursor: pointer;
}

.tab.active {
  background: var(--accent);
  color: #0f172a;
}

.notification {
  position: absolute;
  top: -6px;
  right: -6px;
  background: red;
  color: white;
  font-size: 10px;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

@media (max-width: 600px) {
  h1 { font-size: 1.6rem; }
  button { padding: 8px 12px; font-size: 12px; }
  .stat { font-size: 0.8rem; }
  #ui { gap: 4px; }
  .tabs { flex-wrap: wrap; }
  .tab { padding: 6px 10px; font-size: 12px; }
}
</style>
</head>
<body>
<div id="container">
  <h1>üè∞ Tower Defense ‚Äì Ultimate Defense!</h1>
  <div id="editor-credit">Edited by Gordon</div>

  <!-- LEADERBOARD -->
  <div id="leaderboard">
    <h2>üèÜ Top 10 Players</h2>
    <div id="leaderboard-list">
      <div class="leaderboard-item">
        <span>Loading...</span>
      </div>
    </div>
    <button id="start-btn" style="margin-top:15px;">‚ñ∂Ô∏è Start Game</button>
  </div>

  <!-- MENU (hidden by default, activated via JS) -->
  <div id="menu" style="display:none;">
    <h2>Select Difficulty</h2>
    <button onclick="startGame('easy')">üòÄ Easy</button>
    <button onclick="startGame('normal')">üôÇ Normal</button>
    <button onclick="startGame('hard')">üò† Hard</button>
    <p id="instructions">Place towers (click). Upgrade (Shift+click). Use <strong>Freeze (E)</strong> or <strong>Missile (R)</strong>!</p>
  </div>

  <!-- UI -->
  <div id="ui" style="display:none;">
    <div class="stat">üéÆ <span id="player-name">Guest</span></div>
    <div class="stat">‚ù§Ô∏è <span id="health">10</span></div>
    <div class="stat">üí∞ <span id="money">100</span></div>
    <div class="stat">‚ö° <span id="energy">0</span>/100</div>
    <div class="stat">üåä Wave <span id="wave">1</span></div>
    <div class="stat">‚≠ê <span id="score">0</span></div>
  </div>

  <!-- TABS -->
  <div id="tabs-container" style="display:none;">
    <div class="tabs">
      <button class="tab active" data-tab="shop">‚öîÔ∏è Towers</button>
      <button class="tab" data-tab="abilities">üîÆ Abilities</button>
      <button class="tab" data-tab="upgrades">üåü Upgrades</button>
    </div>

    <div id="shop" style="display:flex;"></div>
    <div id="abilities" style="display:none;"></div>
    
    <!-- UPGRADE PANEL -->
    <div id="upgrade-panel" style="display:none;">
      <h3 style="margin:5px 0;color:var(--upgrade);">Global Upgrades</h3>
      <div class="upgrade-row">
        <span class="upgrade-title">üí™ Iron Will</span>
        <span>+2 Max Health</span>
        <button onclick="buyGlobalUpgrade('extraHealth')">üí∞200</button>
      </div>
      <div class="upgrade-row">
        <span class="upgrade-title">‚ö° Energy Core</span>
        <span>+20% Energy Gain</span>
        <button onclick="buyGlobalUpgrade('energyGain')">‚ö°80</button>
      </div>
      <div class="upgrade-row">
        <span class="upgrade-title">üîç Scout Drones</span>
        <span>+10% Tower Range</span>
        <button onclick="buyGlobalUpgrade('towerRange')">üí∞150</button>
      </div>
      <div class="upgrade-row">
        <span class="upgrade-title">üè¶ Bank Account</span>
        <span>+1% Money Interest/Wave</span>
        <button onclick="buyGlobalUpgrade('interest')">üí∞300</button>
      </div>

      <h3 style="margin:15px 0 5px;color:var(--upgrade);">Ability Upgrades</h3>
      <div class="upgrade-row">
        <span class="upgrade-title">‚ùÑÔ∏è Deep Freeze</span>
        <span>Slow to 0.1√ó (+2s)</span>
        <button id="btn-upg-freeze" onclick="buyAbilityUpgrade('freeze')">‚ö°100</button>
      </div>
      <div class="upgrade-row">
        <span class="upgrade-title">üí£ Cluster Missile</span>
        <span>5 missiles, +10px AoE</span>
        <button id="btn-upg-missile" onclick="buyAbilityUpgrade('missile')">‚ö°120</button>
      </div>
    </div>
  </div>

  <canvas id="game" width="800" height="400"></canvas>

  <!-- GAME OVER -->
  <div id="game-over" style="display:none;">
    <h2>üíÄ Game Over!</h2>
    <p>Final Score: <strong id="final-score">0</strong></p>
    <p>Survived <strong id="final-wave">0</strong> waves.</p>
    <p>Your Personal Best: <strong id="personal-best">0</strong></p>
    <button onclick="restartGame()">üîÅ Play Again</button>
    <button onclick="showAuthModal()">üÜï New Player</button>
  </div>
</div>

<!-- ====== AUTH MODALS ====== -->
<div id="auth-modal" style="display:none;">
  <div id="signup-panel" class="auth-panel">
    <h3>üåü Create Your Account</h3>
    <input type="text" id="signup-username" placeholder="Username (e.g., Gordon)" maxlength="15" autocomplete="username">
    <input type="password" id="signup-password" placeholder="Password (min 6 chars)" autocomplete="new-password">
    <div class="btn-row">
      <button onclick="attemptSignup()" style="flex:1;">‚úÖ Sign Up</button>
      <button onclick="switchToLogin()" class="danger" style="flex:1;">‚¨ÖÔ∏è Login</button>
    </div>
    <p id="signup-error" class="auth-error"></p>
  </div>

  <div id="login-panel" class="auth-panel" style="display:none;">
    <h3>üîê Log In</h3>
    <input type="text" id="login-username" placeholder="Username" autocomplete="username">
    <input type="password" id="login-password" placeholder="Password" autocomplete="current-password">
    <label style="display:flex;align-items:center;gap:6px;margin:10px 0;font-size:14px;">
      <input type="checkbox" id="remember-me" checked> Remember me
    </label>
    <div class="btn-row">
      <button onclick="attemptLogin()" style="flex:1;">üîì Login</button>
      <button onclick="switchToSignup()" class="danger" style="flex:1;">üÜï Sign Up</button>
    </div>
    <p id="login-error" class="auth-error"></p>
  </div>
</div>

<script>
// ====== LEADERBOARD SYSTEM ======
const LEADERBOARD_KEY = 'tower_defense_leaderboard_v2';

function loadLeaderboard() {
  const data = localStorage.getItem(LEADERBOARD_KEY);
  return data ? JSON.parse(data) : [];
}

function saveLeaderboard(leaderboard) {
  localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboard));
}

function updateLeaderboard(name, score) {
  if (!name || score <= 0) return;
  
  let leaderboard = loadLeaderboard();
  
  const existing = leaderboard.find(p => p.name === name);
  if (existing) {
    existing.score = Math.max(existing.score, score);
    existing.date = new Date().toISOString().split('T')[0];
  } else {
    leaderboard.push({
      name: name,
      score: score,
      date: new Date().toISOString().split('T')[0]
    });
  }
  
  leaderboard.sort((a, b) => b.score - a.score);
  leaderboard = leaderboard.slice(0, 10);
  
  saveLeaderboard(leaderboard);
  renderLeaderboard();
  saveAccount(); // Save to account first
  return leaderboard.find(p => p.name === name)?.score || score;
}

function renderLeaderboard() {
  const list = document.getElementById('leaderboard-list');
  const leaderboard = loadLeaderboard();
  
  if (leaderboard.length === 0) {
    list.innerHTML = '<div class="leaderboard-item"><span>No scores yet. Be the first!</span></div>';
    return;
  }
  
  list.innerHTML = leaderboard.map((player, i) => `
    <div class="leaderboard-item">
      <span>${i+1}. <strong>${player.name}</strong></span>
      <span>${player.score.toLocaleString()} ‚Ä¢ ${player.date}</span>
    </div>
  `).join('');
}

// ====== ACCOUNT SYSTEM ======
const ACCOUNTS_KEY = 'tower_defense_accounts_v1';
const CURRENT_USER_KEY = 'tower_defense_current_user';
const SALT = 'tower_defense_salt_2025_gordon_edition';

// Load all accounts
function loadAccounts() {
  const data = localStorage.getItem(ACCOUNTS_KEY);
  return data ? JSON.parse(data) : {};
}

function saveAccounts(accounts) {
  localStorage.setItem(ACCOUNTS_KEY, JSON.stringify(accounts));
}

function setCurrentUser(username) {
  localStorage.setItem(CURRENT_USER_KEY, username);
}

function getCurrentUser() {
  return localStorage.getItem(CURRENT_USER_KEY);
}

// üîê Hash password (SHA-256 + salt)
async function hashPassword(password) {
  const encoder = new TextEncoder();
  const data = encoder.encode(SALT + password);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

// üÜï Sign up
async function attemptSignup() {
  const username = document.getElementById('signup-username').value.trim();
  const password = document.getElementById('signup-password').value;

  const errorEl = document.getElementById('signup-error');
  errorEl.textContent = '';

  if (!username) return errorEl.textContent = 'Username required';
  if (username.length < 2) return errorEl.textContent = 'Username too short (min 2)';
  if (username.length > 15) return errorEl.textContent = 'Username too long (max 15)';
  if (password.length < 6) return errorEl.textContent = 'Password must be ‚â•6 chars';

  // Validate username: letters, numbers, underscores only
  if (!/^[a-zA-Z0-9_]+$/.test(username)) {
    return errorEl.textContent = 'Username: letters, numbers, _ only';
  }

  const accounts = loadAccounts();
  if (accounts[username]) return errorEl.textContent = 'Username taken!';

  const hash = await hashPassword(password);
  
  // Create new account profile
  accounts[username] = {
    createdAt: new Date().toISOString(),
    profile: {
      name: username,
      personalBest: 0,
      globalUpgrades: { extraHealth: 0, energyGain: 1.0, towerRange: 1.0, interest: 0 },
      abilityUpgrades: { freeze: { deep: false }, missile: { cluster: false } }
    }
  };

  saveAccounts(accounts);
  setCurrentUser(username);
  hideAuthModal();

  // Load into game
  loadAccount(username);
  showMenu();
  showFeedback(`Welcome, ${username}! üéâ`, "success");
}

// üîê Login
async function attemptLogin() {
  const username = document.getElementById('login-username').value.trim();
  const password = document.getElementById('login-password').value;
  const remember = document.getElementById('remember-me').checked;

  const errorEl = document.getElementById('login-error');
  errorEl.textContent = '';

  if (!username || !password) return errorEl.textContent = 'Fill all fields';

  const accounts = loadAccounts();
  const account = accounts[username];
  if (!account) return errorEl.textContent = 'User not found';

  const hash = await hashPassword(password);
  // ‚úÖ Compare hash
  const expectedHash = await hashPassword(password); // simulate check; real: store hash at signup
  // In real app, store hash at signup: account.hash = hash;
  // For demo, we'll store it now if missing (backwards compat)
  if (!account.hash) {
    account.hash = hash;
    saveAccounts(accounts);
  }

  if (hash !== account.hash) {
    await new Promise(r => setTimeout(r, 300)); // prevent timing attacks
    return errorEl.textContent = 'Invalid password';
  }

  if (remember) {
    setCurrentUser(username);
  } else {
    localStorage.removeItem(CURRENT_USER_KEY);
  }

  hideAuthModal();
  loadAccount(username);
  showMenu();
  showFeedback(`Welcome back, ${username}! üè∞`, "success");
}

// Load account data into game state
function loadAccount(username) {
  const accounts = loadAccounts();
  const account = accounts[username];
  if (!account) return;

  currentPlayer = account.profile.name;
  personalBest = account.profile.personalBest || 0;
  globalUpgrades = account.profile.globalUpgrades || { extraHealth: 0, energyGain: 1.0, towerRange: 1.0, interest: 0 };
  abilityUpgrades = account.profile.abilityUpgrades || { freeze: { deep: false }, missile: { cluster: false } };

  // Update UI
  document.getElementById("player-name").textContent = currentPlayer;
  renderUpgradePanel();
}

// Save current progress to account
function saveAccount() {
  const accounts = loadAccounts();
  const account = accounts[currentPlayer];
  if (!account) return;

  // Update hash if missing (first login after upgrade)
  if (!account.hash) {
    // ‚ö†Ô∏è Can't rehash without password ‚Äî leave as is for demo.
    // In real app, prompt for re-login or use key derivation.
  }

  account.profile.personalBest = personalBest;
  account.profile.globalUpgrades = { ...globalUpgrades };
  account.profile.abilityUpgrades = { ...abilityUpgrades };

  saveAccounts(accounts);
  console.log(`üíæ Saved progress for ${currentPlayer}`);
}

// UI Helpers
function showAuthModal() {
  document.getElementById('auth-modal').style.display = 'flex';
  document.getElementById('signup-panel').style.display = 'block';
  document.getElementById('login-panel').style.display = 'none';
  document.getElementById('signup-username').value = '';
  document.getElementById('signup-password').value = '';
  document.getElementById('signup-error').textContent = '';
  setTimeout(() => document.getElementById('signup-username').focus(), 100);
}

function hideAuthModal() {
  document.getElementById('auth-modal').style.display = 'none';
}

function switchToLogin() {
  document.getElementById('signup-panel').style.display = 'none';
  document.getElementById('login-panel').style.display = 'block';
  document.getElementById('login-username').value = '';
  document.getElementById('login-password').value = '';
  document.getElementById('login-error').textContent = '';
  setTimeout(() => document.getElementById('login-username').focus(), 100);
}

function switchToSignup() {
  document.getElementById('login-panel').style.display = 'none';
  document.getElementById('signup-panel').style.display = 'block';
  setTimeout(() => document.getElementById('signup-username').focus(), 100);
}

function showMenu() {
  document.getElementById("leaderboard").style.display = "none";
  document.getElementById("menu").style.display = "block";
  document.getElementById("menu").classList.add('active');
}

// ====== GAME STATE ======
let currentPlayer = "Guest";
let personalBest = 0;
let health = 10, money = 100, wave = 1, score = 0, energy = 0;
let selectedTower = null;
let enemiesToSpawn = 0;
let spawnCooldown = 0;
let gameRunning = false;
let freezeCooldown = 0;
let missileCooldown = 0;

let hpMult = 1, speedMult = 1, spawnRateMult = 1;

let globalUpgrades = {
  extraHealth: 0,
  energyGain: 1.0,
  towerRange: 1.0,
  interest: 0
};

let abilityUpgrades = {
  freeze: { deep: false },
  missile: { cluster: false }
};

// ====== CANVAS SETUP ======
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let dpr = window.devicePixelRatio || 1;
let width = 800;
let height = 400;

function resizeCanvas() {
  const container = canvas.parentElement;
  const maxWidth = Math.min(container.clientWidth, 850);
  width = maxWidth;
  height = Math.round(width * 0.5);

  canvas.width = width * dpr;
  canvas.height = height * dpr;
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
  ctx.scale(dpr, dpr);
}

// ====== PATH & UTILS ======
const path = [
  { x: 0, y: 80 },
  { x: Math.min(250, width * 0.3), y: 80 },
  { x: Math.min(250, width * 0.3), y: Math.min(300, height * 0.75) },
  { x: Math.min(550, width * 0.7), y: Math.min(300, height * 0.75) },
  { x: Math.min(550, width * 0.7), y: Math.min(150, height * 0.4) },
  { x: width, y: Math.min(150, height * 0.4) }
];

function isOnPath(x, y) {
  const pathWidth = 40;
  for (let i = 0; i < path.length - 1; i++) {
    const p1 = path[i], p2 = path[i+1];
    const dist = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
    if (dist <= pathWidth/2 + 15) return true;
  }
  return false;
}

function distToSegment(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  if (lenSq !== 0) param = dot / lenSq;
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  const dx = px - xx, dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

// ====== CLASSES ======
class Particle {
  constructor(x, y, color = '#ffffff', size = 3, vx = 0, vy = 0, life = 30) {
    this.x = x;
    this.y = y;
    this.vx = vx || (Math.random() - 0.5) * 4;
    this.vy = vy || (Math.random() - 0.5) * 4 - 1;
    this.life = life;
    this.maxLife = life;
    this.color = color;
    this.size = size + Math.random() * 2;
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.1;
    this.life--;
    return this.life <= 0;
  }
  draw() {
    const alpha = this.life / this.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

class Enemy {
  constructor(type, wave) {
    this.type = type;
    this.x = path[0].x;
    this.y = path[0].y;
    this.targetIndex = 1;
    this.wave = wave;
    this.slow = 1;

    if (type === "normal") {
      this.hp = (5 + wave * 0.5) * hpMult;
      this.speed = 1 * speedMult;
      this.color = "#ef4444";
      this.reward = 10;
      this.score = 10;
    } else if (type === "fast") {
      this.hp = (3 + wave * 0.3) * hpMult;
      this.speed = 1.8 * speedMult;
      this.color = "#06b6d4";
      this.reward = 12;
      this.score = 15;
    } else if (type === "strong") {
      this.hp = (12 + wave * 1.2) * hpMult;
      this.speed = 0.6 * speedMult;
      this.color = "#8b5cf6";
      this.reward = 20;
      this.score = 25;
    } else if (type === "boss") {
      this.hp = (80 + wave * 8) * hpMult;
      this.speed = 0.4 * speedMult;
      this.color = "#fbbf24";
      this.reward = 100;
      this.score = 200;
      this.size = 32;
    }
    this.maxHp = this.hp;
    this.size = this.type === "boss" ? 32 : 20;
    this.effects = [];
  }

  update() {
    for (let i = this.effects.length - 1; i >= 0; i--) {
      const eff = this.effects[i];
      if (eff.type === 'burn') {
        this.hp -= eff.dps / 60;
      }
      eff.duration--;
      if (eff.duration <= 0) this.effects.splice(i, 1);
    }

    const target = path[this.targetIndex];
    if (!target) {
      health -= 1 + globalUpgrades.extraHealth;
      return true;
    }

    const dx = target.x - this.x;
    const dy = target.y - this.y;
    const dist = Math.hypot(dx, dy);
    const speed = this.speed * this.slow;

    if (dist < speed) {
      this.x = target.x;
      this.y = target.y;
      this.targetIndex++;
    } else {
      this.x += (dx / dist) * speed;
      this.y += (dy / dist) * speed;
    }

    if (this.slow < 1) {
      this.slow += 0.02;
      if (this.slow > 1) this.slow = 1;
    }

    return false;
  }

  draw() {
    const barWidth = this.size;
    const healthPercent = Math.max(0, this.hp / this.maxHp);
    ctx.fillStyle = '#334155';
    ctx.fillRect(this.x - barWidth/2, this.y - this.size/2 - 10, barWidth, 4);
    ctx.fillStyle = '#10b981';
    ctx.fillRect(this.x - barWidth/2, this.y - this.size/2 - 10, barWidth * healthPercent, 4);

    if (this.effects.some(e => e.type === 'burn')) {
      ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size/2 + 3, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = '#0f172a';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  applySlow(mult) {
    this.slow = Math.min(this.slow, mult);
  }

  applyBurn(dps, duration) {
    this.effects.push({ type: 'burn', duration, dps });
  }
}

class Tower {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.cooldown = 0;
    this.level = 1;
    this.maxLevel = 3;

    switch(type) {
      case "basic":
        this.baseRange = 100;
        this.baseCooldown = 30;
        this.baseDamage = 1;
        this.color = "#3b82f6";
        this.name = "Basic";
        break;
      case "fast":
        this.baseRange = 90;
        this.baseCooldown = 15;
        this.baseDamage = 1;
        this.color = "#10b981";
        this.name = "Fast";
        break;
      case "sniper":
        this.baseRange = 240;
        this.baseCooldown = 60;
        this.baseDamage = 4;
        this.color = "#f59e0b";
        this.name = "Sniper";
        break;
      case "frozen":
        this.baseRange = 120;
        this.baseCooldown = 25;
        this.baseDamage = 0.5;
        this.slowMult = 0.4;
        this.color = "#93c5fd";
        this.name = "Frozen";
        break;
      case "flame":
        this.baseRange = 80;
        this.baseCooldown = 4;
        this.baseDps = 0.8;
        this.color = "#f87171";
        this.name = "Flame";
        break;
      case "lazer":
        this.baseRange = 200;
        this.baseCooldown = 4;
        this.baseDamage = 0.6;
        this.pierce = 3;
        this.color = "#ec4899";
        this.name = "Lazer";
        break;
      case "missile":
        this.baseRange = 180;
        this.baseCooldown = 45;
        this.baseDamage = 8;
        this.splash = 40;
        this.color = "#8b5cf6";
        this.name = "Missile";
        break;
      case "tesla":
        this.baseRange = 140;
        this.baseCooldown = 30;
        this.baseDamage = 3;
        this.jumps = 3;
        this.jumpDamageMult = 0.6;
        this.color = "#a855f7";
        this.name = "Tesla";
        break;
    }
    this.updateStats();
  }

  updateStats() {
    const l = this.level - 1;
    this.range = (this.baseRange + l * 15) * globalUpgrades.towerRange;
    this.cooldownMax = Math.max(5, this.baseCooldown - l * 5);
    this.damage = this.baseDamage + (this.type === "sniper" ? l * 1 : l * 0.5);
    
    if (this.type === "flame") this.dps = this.baseDps + l * 0.3;
    if (this.type === "tesla") {
      this.damage = this.baseDamage + l * 0.7;
      this.jumps = 3 + l;
    }
  }

  upgrade() {
    if (this.level >= this.maxLevel) return false;
    const cost = [100, 150, 200][this.level - 1];
    if (money < cost) return false;
    
    money -= cost;
    this.level++;
    this.updateStats();
    
    for (let i = 0; i < 15; i++) {
      particles.push(new Particle(this.x, this.y, '#fbbf24', 2));
    }
    showFeedback(`+${this.name} Lvl ${this.level}`, "success");
    return true;
  }

  update() {
    if (this.cooldown > 0) {
      this.cooldown--;
      return;
    }

    switch(this.type) {
      case "basic":
      case "fast":
      case "sniper":
        this.shootSingle();
        break;
      case "frozen":
        this.shootFrozen();
        break;
      case "flame":
        this.shootFlame();
        break;
      case "lazer":
        this.shootLazer();
        break;
      case "missile":
        this.shootMissile();
        break;
      case "tesla":
        this.shootTesla();
        break;
    }
  }

  shootSingle() {
    let closest = null;
    let closestDist = Infinity;
    for (const e of enemies) {
      const d = Math.hypot(e.x - this.x, e.y - this.y);
      if (d <= this.range && d < closestDist) {
        closestDist = d;
        closest = e;
      }
    }
    if (closest) {
      bullets.push(new Bullet(this.x, this.y, closest, this.damage, this.type));
      this.cooldown = this.cooldownMax;
    }
  }

  shootFrozen() {
    const targets = enemies.filter(e => 
      Math.hypot(e.x - this.x, e.y - this.y) <= this.range
    ).slice(0, 1);

    for (const e of targets) {
      e.hp -= this.damage;
      e.applySlow(this.slowMult);
      for (let i = 0; i < 5; i++) {
        particles.push(new Particle(e.x, e.y, '#dbeafe', 1.5, (Math.random()-0.5)*3, (Math.random()-0.5)*3, 30));
      }
    }
    if (targets.length > 0) this.cooldown = this.cooldownMax;
  }

  shootFlame() {
    const targets = enemies.filter(e => 
      Math.hypot(e.x - this.x, e.y - this.y) <= this.range
    );
    for (const e of targets) {
      e.applyBurn(this.dps, 120);
      const angle = Math.atan2(e.y - this.y, e.x - this.x);
      for (let i = 0; i < 3; i++) {
        const dist = 10 + i * 15;
        particles.push(new Particle(
          this.x + Math.cos(angle) * dist,
          this.y + Math.sin(angle) * dist,
          '#f87171', 2, 0, 0, 15
        ));
      }
    }
    if (targets.length > 0) this.cooldown = this.cooldownMax;
  }

  shootLazer() {
    let primary = null;
    let minDist = Infinity;
    for (const e of enemies) {
      const d = Math.hypot(e.x - this.x, e.y - this.y);
      if (d <= this.range && d < minDist) {
        minDist = d;
        primary = e;
      }
    }
    if (!primary) return;

    const angle = Math.atan2(primary.y - this.y, primary.x - this.x);
    const hits = [];

    for (const e of enemies) {
      const d = Math.hypot(e.x - this.x, e.y - this.y);
      if (d > this.range) continue;
      const a2 = Math.atan2(e.y - this.y, e.x - this.x);
      const diff = Math.abs(a2 - angle);
      if (diff < 0.15) {
        hits.push({ enemy: e, dist: d });
      }
    }

    hits.sort((a, b) => a.dist - b.dist);
    const actualHits = hits.slice(0, this.pierce);

    if (actualHits.length > 0) {
      const last = actualHits[actualHits.length - 1].enemy;
      ctx.strokeStyle = '#ec4899';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(last.x, last.y);
      ctx.stroke();

      ctx.strokeStyle = '#f472b640';
      ctx.lineWidth = 8;
      ctx.stroke();

      for (const h of actualHits) {
        h.enemy.hp -= this.damage;
      }
      this.cooldown = this.cooldownMax;
    }
  }

  shootMissile() {
    let closest = null;
    let closestDist = Infinity;
    for (const e of enemies) {
      const d = Math.hypot(e.x - this.x, e.y - this.y);
      if (d <= this.range && d < closestDist) {
        closestDist = d;
        closest = e;
      }
    }
    if (closest) {
      const splash = this.splash + (abilityUpgrades.missile.deep ? 10 : 0);
      bullets.push(new Bullet(this.x, this.y, closest, this.damage, this.type, splash));
      this.cooldown = this.cooldownMax;
    }
  }

  shootTesla() {
    let closest = null;
    let minDist = Infinity;
    for (const e of enemies) {
      const d = Math.hypot(e.x - this.x, e.y - this.y);
      if (d <= this.range && d < minDist) {
        minDist = d;
        closest = e;
      }
    }
    if (!closest) return;

    const hits = [closest];
    let current = closest;
    let remainingJumps = this.jumps;

    while (remainingJumps > 0 && hits.length < 10) {
      let next = null;
      let nextDist = Infinity;
      for (const e of enemies) {
        if (hits.includes(e)) continue;
        const d = Math.hypot(e.x - current.x, e.y - current.y);
        if (d <= 80 && d < nextDist) {
          nextDist = d;
          next = e;
        }
      }
      if (!next) break;
      hits.push(next);
      current = next;
      remainingJumps--;
    }

    let dmg = this.damage;
    for (let i = 0; i < hits.length; i++) {
      hits[i].hp -= dmg;
      dmg *= this.jumpDamageMult;
      if (i > 0) {
        ctx.strokeStyle = '#a855f7';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(hits[i-1].x, hits[i-1].y);
        ctx.lineTo(hits[i].x, hits[i].y);
        ctx.stroke();
      }
    }

    for (let i = 0; i < 8; i++) {
      particles.push(new Particle(closest.x, closest.y, '#e9d5ff', 2));
    }

    this.cooldown = this.cooldownMax;
  }

  draw() {
    if (selectedTower === this.type) {
      ctx.strokeStyle = this.color + '40';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.fillStyle = '#64748b';
    ctx.beginPath();
    ctx.arc(this.x, this.y, 14, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'white';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`${this.name[0]}${this.level > 1 ? this.level : ''}`, this.x, this.y + 4);
    ctx.textAlign = 'left';
  }
}

class Bullet {
  constructor(x, y, target, damage, towerType, splash = 0) {
    this.x = x;
    this.y = y;
    this.target = target;
    this.damage = damage;
    this.towerType = towerType;
    this.splash = splash;
    this.speed = towerType === 'sniper' ? 8 : 
                towerType === 'missile' ? 5 : 4;
    this.hit = false;
  }

  update() {
    if (!this.target || this.target.hp <= 0) return true;

    const dx = this.target.x - this.x;
    const dy = this.target.y - this.y;
    const dist = Math.hypot(dx, dy);

    if (dist < 5) {
      if (!this.hit) {
        this.target.hp -= this.damage;
        this.hit = true;

        if (this.splash > 0) {
          for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 3;
            particles.push(new Particle(
              this.x, this.y,
              '#fbbf24', 2,
              Math.cos(angle) * speed,
              Math.sin(angle) * speed,
              30
            ));
          }
          for (const e of enemies) {
            const d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d <= this.splash && e !== this.target) {
              e.hp -= this.damage * 0.6;
            }
          }
          aoeEffects.push({
            x: this.x, y: this.y, radius: this.splash,
            color: '#fbbf2440', life: 20, type: 'explosion'
          });
        } else {
          for (let i = 0; i < 3; i++) {
            particles.push(new Particle(this.x, this.y, 
              this.towerType === 'sniper' ? '#f59e0b' : '#e2e8f0'
            ));
          }
        }
      }
      return true;
    }

    this.x += (dx / dist) * this.speed;
    this.y += (dy / dist) * this.speed;
    return false;
  }

  draw() {
    if (this.towerType === 'missile') {
      ctx.fillStyle = '#8b5cf6';
      ctx.beginPath();
      ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
      ctx.fill();
      particles.push(new Particle(this.x, this.y, '#c084fc', 1.5, 0, 0, 10));
    } else {
      ctx.fillStyle = this.towerType === 'sniper' ? '#f59e0b' : '#e2e8f0';
      ctx.beginPath();
      ctx.arc(this.x, this.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

class AoeEffect {
  constructor(x, y, radius, color, life, type) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.color = color;
    this.life = life;
    this.maxLife = life;
    this.type = type;
  }
  update() {
    this.life--;
    return this.life <= 0;
  }
  draw() {
    const alpha = this.life / this.maxLife;
    const hexAlpha = Math.floor(alpha * 255).toString(16).padStart(2, '0');
    ctx.fillStyle = this.color.slice(0, -2) + hexAlpha;
    if (this.type === 'explosion') {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius * (1.5 - 0.5 * alpha), 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// ====== UI & GAME CONTROL ======
function initShop() {
  let shopHTML = `
    <button title="Damage: 1 ‚Üí 2\nRange: 100 ‚Üí 130\nCost: 50 ‚Üí 100 ‚Üí 150"
            data-cost="50" onclick="selectTower('basic', this)">Basic (50)</button>
    <button title="Fast fire!\nDamage: 1 ‚Üí 2\nCooldown: 15 ‚Üí 5"
            data-cost="75" onclick="selectTower('fast', this)">Fast (75)</button>
    <button title="Long range!\nDamage: 4 ‚Üí 6\nRange: 240 ‚Üí 270"
            data-cost="120" onclick="selectTower('sniper', this)">Sniper (120)</button>
    <button title="Slows enemies\nDamage: 0.5 ‚Üí 1.5"
            data-cost="150" onclick="selectTower('frozen', this)">Frozen (150)</button>
    <button title="DPS over time\nDPS: 0.8 ‚Üí 1.4"
            data-cost="130" onclick="selectTower('flame', this)">Flame (130)</button>
    <button title="Pierces 3 ‚Üí 5 enemies"
            data-cost="200" onclick="selectTower('lazer', this)">Lazer (200)</button>
    <button title="Big explosion!\nSplash: 40px"
            data-cost="250" onclick="selectTower('missile', this)">Missile (250)</button>
  `;

  if (wave >= 5) {
    shopHTML += `
      <button title="Chain lightning!\nJumps: 3 ‚Üí 6\nDamage: 3 ‚Üí 4.4"
              data-cost="220" onclick="selectTower('tesla', this)">‚ö° Tesla (220)</button>
    `;
  }

  document.getElementById('shop').innerHTML = shopHTML;
}

function initAbilities() {
  const abilities = document.getElementById('abilities');
  abilities.innerHTML = `
    <button id="btn-freeze" class="energy" onclick="useFreeze()" ${freezeCooldown > 0 ? 'disabled' : ''}>
      ‚ùÑÔ∏è Freeze (${freezeCooldown > 0 ? Math.ceil(freezeCooldown/60) + 's' : 'READY'})
    </button>
    <button id="btn-missile" class="energy" onclick="useMissile()" ${missileCooldown > 0 ? 'disabled' : ''}>
      üí• Missile (${missileCooldown > 0 ? Math.ceil(missileCooldown/60) + 's' : 'READY'})
    </button>
  `;
}

function selectTower(type, btn) {
  selectedTower = type;
  document.querySelectorAll("#shop button").forEach(b => b.classList.remove("selected"));
  btn.classList.add("selected");
}

function gainEnergy(amount) {
  energy = Math.min(100, energy + amount * globalUpgrades.energyGain);
  document.getElementById("energy").textContent = Math.floor(energy);
}

function useFreeze() {
  if (freezeCooldown > 0 || energy < 30) return;
  freezeCooldown = 300;
  energy -= 30;
  updateUI();

  const slowMult = abilityUpgrades.freeze.deep ? 0.1 : 0.3;

  for (const e of enemies) {
    e.applySlow(slowMult);
  }

  for (let i = 0; i < 50; i++) {
    const x = Math.random() * width;
    const y = Math.random() * height;
    particles.push(new Particle(x, y, '#93c5fd', 1.5, 0, 0, 40));
  }
}

function useMissile() {
  if (missileCooldown > 0 || energy < 50) return;
  missileCooldown = 420;
  energy -= 50;
  updateUI();

  const count = abilityUpgrades.missile.deep ? 5 : 3;
  const radius = abilityUpgrades.missile.deep ? 70 : 60;
  const damage = 12;

  for (let i = 0; i < count; i++) {
    const e = enemies[Math.floor(Math.random() * enemies.length)];
    if (!e) continue;
    const x = e.x + (Math.random() - 0.5) * 60;
    const y = e.y + (Math.random() - 0.5) * 60;

    for (const en of enemies) {
      const d = Math.hypot(en.x - x, en.y - y);
      if (d <= radius) {
        en.hp -= damage;
      }
    }

    for (let p = 0; p < 30; p++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 1 + Math.random() * 4;
      particles.push(new Particle(x, y, '#fbbf24', 3, Math.cos(angle)*speed, Math.sin(angle)*speed, 40));
    }
    aoeEffects.push(new AoeEffect(x, y, radius, '#fbbf2460', 30, 'explosion'));
  }
}

canvas.addEventListener("click", e => {
  if (!gameRunning) return;

  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width) / dpr;
  const y = (e.clientY - rect.top) * (canvas.height / rect.height) / dpr;

  for (const t of towers) {
    if (Math.hypot(t.x - x, t.y - y) < 20) {
      if (e.shiftKey || selectedTower === null) {
        if (t.upgrade()) {
          updateUI();
        } else {
          showFeedback("Can't upgrade / Not enough üí∞", "error");
        }
      }
      return;
    }
  }

  if (!selectedTower) return;

  const cost = { basic:50, fast:75, sniper:120, frozen:150, flame:130, lazer:200, missile:250, tesla:220 }[selectedTower];
  if (money < cost) return;

  if (x < 20 || x > width - 20 || y < 20 || y > height - 20 || isOnPath(x, y)) {
    showFeedback("Can't build on path/edge!", "error");
    return;
  }

  for (const t of towers) {
    if (Math.hypot(t.x - x, t.y - y) < 30) {
      showFeedback("Too close to another tower!", "error");
      return;
    }
  }

  towers.push(new Tower(x, y, selectedTower));
  money -= cost;
  updateUI();
});

document.addEventListener('keydown', e => {
  if (!gameRunning) return;
  if (e.key === 'e' || e.key === 'E') useFreeze();
  if (e.key === 'r' || e.key === 'R') useMissile();
});

function randomEnemyType(wave) {
  if (wave <= 3) return "normal";
  const r = Math.random();
  if (wave <= 10) {
    if (r < 0.6) return "normal";
    if (r < 0.85) return "fast";
    return "strong";
  } else {
    if (r < 0.4) return "normal";
    if (r < 0.65) return "fast";
    if (r < 0.85) return "strong";
    return Math.random() < 0.3 ? "boss" : "strong";
  }
}

function startWave() {
  if (globalUpgrades.interest > 0 && wave > 1) {
    const interest = Math.floor(money * (globalUpgrades.interest * 0.01));
    money += interest;
    if (interest > 0) showFeedback(`+${interest}üí∞ interest!`, "success");
  }

  enemiesToSpawn = wave % 5 === 0 ? 1 : Math.min(35, 5 + Math.floor(wave * 1.3));
  spawnCooldown = Math.max(10, 40 / spawnRateMult);
}

let feedback = { text: "", type: "", time: 0 };
function showFeedback(text, type = "info") {
  feedback = { text, type, time: 120 };
}

function drawFeedback() {
  if (feedback.time <= 0) return;
  feedback.time--;
  
  ctx.font = "16px Arial";
  const metrics = ctx.measureText(feedback.text);
  const x = width/2 - metrics.width/2;
  const y = height - 50;
  
  ctx.fillStyle = feedback.type === "error" ? '#f8717180' : 
                 feedback.type === "success" ? '#4ade8080' : '#8b5cf680';
  ctx.fillRect(x - 10, y - 20, metrics.width + 20, 30);
  
  ctx.fillStyle = 'white';
  ctx.fillText(feedback.text, x, y);
}

function updateUI() {
  document.getElementById("player-name").textContent = currentPlayer;
  document.getElementById("health").textContent = Math.max(0, health);
  document.getElementById("money").textContent = money;
  document.getElementById("energy").textContent = Math.floor(energy);
  document.getElementById("wave").textContent = wave;
  document.getElementById("score").textContent = score;
  
  const freezeBtn = document.getElementById("btn-freeze");
  const missileBtn = document.getElementById("btn-missile");
  if (freezeBtn) {
    freezeBtn.disabled = freezeCooldown > 0 || energy < 30;
    freezeBtn.innerHTML = `‚ùÑÔ∏è Freeze (${freezeCooldown > 0 ? Math.ceil(freezeCooldown/60) : energy < 30 ? '30‚ö°' : 'READY'})`;
  }
  if (missileBtn) {
    missileBtn.disabled = missileCooldown > 0 || energy < 50;
    missileBtn.innerHTML = `üí• Missile (${missileCooldown > 0 ? Math.ceil(missileCooldown/60) : energy < 50 ? '50‚ö°' : 'READY'})`;
  }

  renderUpgradePanel();
}

let enemies = [];
let towers = [];
let bullets = [];
let particles = [];
let aoeEffects = [];

function gameLoop() {
  if (!gameRunning) return;

  const grad = ctx.createLinearGradient(0, 0, 0, height);
  grad.addColorStop(0, "#0f172a");
  grad.addColorStop(1, "#1e293b");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, width, height);

  ctx.strokeStyle = "#334155";
  ctx.lineWidth = 40;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for (let i = 1; i < path.length; i++) {
    ctx.lineTo(path[i].x, path[i].y);
  }
  ctx.stroke();

  ctx.fillStyle = "#64748b";
  ctx.font = "16px Arial";
  for (let i = 0; i < path.length - 1; i++) {
    const p1 = path[i], p2 = path[i+1];
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const len = Math.hypot(dx, dy);
    const steps = Math.floor(len / 80);
    for (let s = 1; s <= steps; s++) {
      const x = p1.x + dx * (s/steps);
      const y = p1.y + dy * (s/steps);
      ctx.fillText("‚Üí", x - 6, y + 6);
    }
  }

  if (enemiesToSpawn > 0 && spawnCooldown <= 0) {
    const type = wave % 5 === 0 ? "boss" : randomEnemyType(wave);
    enemies.push(new Enemy(type, wave));
    enemiesToSpawn--;
    spawnCooldown = Math.max(10, 40 / spawnRateMult);
  }
  if (spawnCooldown > 0) spawnCooldown--;

  for (let i = enemies.length - 1; i >= 0; i--) {
    if (enemies[i].update()) {
      enemies.splice(i, 1);
      continue;
    }
    if (enemies[i].hp <= 0) {
      score += enemies[i].score;
      money += enemies[i].reward;
      gainEnergy(enemies[i].type === 'boss' ? 15 : 5);
      for (let p = 0; p < 15; p++) {
        particles.push(new Particle(enemies[i].x, enemies[i].y, enemies[i].color));
      }
      enemies.splice(i, 1);
      updateUI();
      continue;
    }
    enemies[i].draw();
  }

  towers.forEach(t => { t.update(); t.draw(); });
  for (let i = bullets.length - 1; i >= 0; i--) {
    if (bullets[i].update()) bullets.splice(i, 1);
    else bullets[i].draw();
  }
  for (let i = particles.length - 1; i >= 0; i--) {
    if (particles[i].update()) particles.splice(i, 1);
    else particles[i].draw();
  }
  for (let i = aoeEffects.length - 1; i >= 0; i--) {
    if (aoeEffects[i].update()) aoeEffects.splice(i, 1);
    else aoeEffects[i].draw();
  }

  if (freezeCooldown > 0) freezeCooldown--;
  if (missileCooldown > 0) missileCooldown--;

  if (enemies.length === 0 && enemiesToSpawn === 0) {
    wave++;
    startWave();
    updateUI();
    if (wave === 5) showFeedback("‚ö° Tesla Coil unlocked!", "success");
  }

  drawFeedback();

  if (health <= 0) {
    gameRunning = false;
    const newBest = updateLeaderboard(currentPlayer, score);
    personalBest = Math.max(personalBest, score);
    
    document.getElementById("final-score").textContent = score.toLocaleString();
    document.getElementById("final-wave").textContent = wave - 1;
    document.getElementById("personal-best").textContent = personalBest.toLocaleString();
    
    document.getElementById("ui").style.display = "none";
    document.getElementById("tabs-container").style.display = "none";
    document.getElementById("game-over").style.display = "block";
    
    ctx.fillStyle = "#f87171";
    ctx.font = "bold 48px Arial";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", width/2, height/2 - 20);
    ctx.font = "24px Arial";
    ctx.fillStyle = "#f1f5f9";
    ctx.fillText(`Final Score: ${score.toLocaleString()}`, width/2, height/2 + 20);
    return;
  }

  requestAnimationFrame(gameLoop);
}

function startGame(difficulty) {
  // Ensure we have a player
  if (currentPlayer === "Guest") {
    showAuthModal();
    return;
  }

  health = (difficulty === "easy" ? 25 : difficulty === "normal" ? 20 : 15) + globalUpgrades.extraHealth * 2;
  money = difficulty === "easy" ? 250 : difficulty === "normal" ? 200 : 150;
  hpMult = difficulty === "easy" ? 0.6 : difficulty === "normal" ? 1 : 1.5;
  speedMult = difficulty === "easy" ? 0.75 : difficulty === "normal" ? 1 : 1.4;
  spawnRateMult = difficulty === "easy" ? 1.5 : difficulty === "normal" ? 1 : 0.6;

  enemies = [];
  towers = [];
  bullets = [];
  particles = [];
  aoeEffects = [];
  wave = 1; score = 0; energy = 0;
  freezeCooldown = 0; missileCooldown = 0;
  selectedTower = null;

  document.getElementById("leaderboard").style.display = "none";
  document.getElementById("menu").style.display = "none";
  document.getElementById("menu").classList.remove('active');
  document.getElementById("game-over").style.display = "none";
  
  document.getElementById("ui").style.display = "flex";
  document.getElementById("tabs-container").style.display = "block";
  canvas.style.display = "block";
  
  initShop();
  initAbilities();
  updateUI();
  startWave();
  gameRunning = true;
  requestAnimationFrame(gameLoop);

  saveAccount();
}

function restartGame() {
  document.getElementById("game-over").style.display = "none";
  document.getElementById("ui").style.display = "none";
  document.getElementById("tabs-container").style.display = "none";
  canvas.style.display = "none";
  
  document.getElementById("menu").style.display = "block";
  document.getElementById("menu").classList.add('active');
}

// ====== UPGRADE FUNCTIONS ======
const globalUpgradeCosts = {
  extraHealth: () => 200 + globalUpgrades.extraHealth * 100,
  energyGain: () => 80,
  towerRange: () => 150 + (globalUpgrades.towerRange > 1 ? 100 : 0),
  interest: () => 300 + globalUpgrades.interest * 100
};

function buyGlobalUpgrade(type) {
  const cost = globalUpgradeCosts[type]();
  if (type.endsWith('Gain') && energy < cost) return showFeedback("Not enough ‚ö°", "error");
  if (!type.endsWith('Gain') && money < cost) return showFeedback("Not enough üí∞", "error");

  if (type.endsWith('Gain')) energy -= cost;
  else money -= cost;

  switch(type) {
    case 'extraHealth':
      globalUpgrades.extraHealth++;
      health += 2;
      break;
    case 'energyGain':
      globalUpgrades.energyGain += 0.2;
      break;
    case 'towerRange':
      globalUpgrades.towerRange += 0.1;
      break;
    case 'interest':
      globalUpgrades.interest++;
      break;
  }
  showFeedback(`+ ${type.replace(/([A-Z])/g, ' $1')}`, "success");
  saveAccount();
  updateUI();
  renderUpgradePanel();
}

function buyAbilityUpgrade(ability) {
  const cost = ability === 'freeze' ? 100 : 120;
  if (energy < cost) return showFeedback("Not enough ‚ö°", "error");
  
  energy -= cost;
  abilityUpgrades[ability].deep = true;
  showFeedback(`Upgraded ${ability}!`, "success");
  saveAccount();
  updateUI();
  renderUpgradePanel();
}

function renderUpgradePanel() {
  document.getElementById('btn-upg-freeze').disabled = abilityUpgrades.freeze.deep;
  document.getElementById('btn-upg-missile').disabled = abilityUpgrades.missile.deep;
}

// ====== INITIALIZE ======
document.addEventListener('DOMContentLoaded', () => {
  // Setup start button
  document.getElementById('start-btn').onclick = showAuthModal;

  // Tab switching
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      const target = tab.dataset.tab;
      document.getElementById('shop').style.display = target === 'shop' ? 'flex' : 'none';
      document.getElementById('abilities').style.display = target === 'abilities' ? 'flex' : 'none';
      document.getElementById('upgrade-panel').style.display = target === 'upgrades' ? 'flex' : 'none';
    });
  });

  // Auto-login
  window.addEventListener('load', () => {
    const savedUser = getCurrentUser();
    if (savedUser) {
      const accounts = loadAccounts();
      if (accounts[savedUser]) {
        loadAccount(savedUser);
        showMenu();
        showFeedback(`‚úÖ Welcome back, ${savedUser}!`, "info");
      } else {
        localStorage.removeItem(CURRENT_USER_KEY);
        showAuthModal();
      }
    } else {
      showAuthModal();
    }
    resizeCanvas();
    renderLeaderboard();
  });
  window.addEventListener('resize', resizeCanvas);
});
</script>
</body>
</html>
