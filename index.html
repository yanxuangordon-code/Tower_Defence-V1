<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tower Defense ‚Äì Debug Mode</title>
<style>
body { 
  margin: 0; 
  background: #0c0e1a; 
  color: #e2e8f0; 
  font-family: Arial, sans-serif; 
  text-align: center; 
}
#debug-panel {
  position: fixed;
  top: 10px;
  right: 10px;
  background: rgba(26, 31, 54, 0.95);
  border: 1px solid #4a5568;
  border-radius: 8px;
  padding: 10px;
  font-size: 12px;
  z-index: 1000;
  max-width: 300px;
}
.debug-row {
  display: flex;
  justify-content: space-between;
  margin: 4px 0;
}
.debug-label { color: #a0aec0; }
.debug-value { font-weight: bold; }
.debug-true { color: #38a169; }
.debug-false { color: #e53e3e; }
canvas { 
  background: #0c0e1a; 
  display: block; 
  margin: 20px auto; 
  border: 1px solid #2d3748;
  border-radius: 8px;
}
#instructions {
  margin: 15px;
  padding: 10px;
  background: #1a1f36;
  border-radius: 8px;
  max-width: 800px;
  margin: 15px auto;
}
</style>
</head>
<body>
<h1>üè∞ Tower Defense ‚Äì Placement Debugger</h1>
<div id="instructions">
  <p><strong>DEBUG MODE ACTIVE</strong> - Red zones = blocked areas | Green zones = safe to build</p>
  <p>1. Select a tower type<br>
  2. Move mouse around canvas to see debug info<br>
  3. Click to attempt placement</p>
</div>

<div id="debug-panel">
  <div class="debug-row">
    <span class="debug-label">Mouse Position:</span>
    <span id="mouse-pos" class="debug-value">-</span>
  </div>
  <div class="debug-row">
    <span class="debug-label">On Path:</span>
    <span id="on-path" class="debug-value">-</span>
  </div>
  <div class="debug-row">
    <span class="debug-label">Near Edge:</span>
    <span id="near-edge" class="debug-value">-</span>
  </div>
  <div class="debug-row">
    <span class="debug-label">Near Tower:</span>
    <span id="near-tower" class="debug-value">-</span>
  </div>
  <div class="debug-row">
    <span class="debug-label">Can Place:</span>
    <span id="can-place" class="debug-value">-</span>
  </div>
  <div class="debug-row">
    <span class="debug-label">Last Error:</span>
    <span id="last-error" class="debug-value">-</span>
  </div>
</div>

<!-- SHOP -->
<div id="shop" style="margin: 15px;">
  <button onclick="selectTower('basic')">Basic (60)</button>
  <button onclick="selectTower('frozen')">Frozen (180)</button>
  <button onclick="selectTower('flame')">Flame (160)</button>
</div>

<canvas id="game" width="800" height="400"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// Game state
let selectedTower = null;
let towers = [];
const TOWER_COSTS = { basic: 60, frozen: 180, flame: 160 };

// Path
const path = [
  { x: 0, y: 80 },
  { x: 250, y: 80 },
  { x: 250, y: 300 },
  { x: 550, y: 300 },
  { x: 550, y: 150 },
  { x: 800, y: 150 }
];

// Mouse position
let mouseX = 0, mouseY = 0;
let lastError = "";

// Debug functions
function isOnPath(x, y) {
  const pathWidth = 40;
  for (let i = 0; i < path.length - 1; i++) {
    const p1 = path[i], p2 = path[i+1];
    const dist = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
    // FIXED: Reduced buffer from +15 to +5
    if (dist <= pathWidth/2 + 5) return true; // Was +15
  }
  return false;
}

function distToSegment(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  if (lenSq !== 0) param = dot / lenSq;
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  const dx = px - xx, dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

// Tower class
class Tower {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
  }
  draw() {
    ctx.fillStyle = typeColors[this.type] || "#3182ce";
    ctx.beginPath();
    ctx.arc(this.x, this.y, 14, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#0c0e1a";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

const typeColors = {
  basic: "#3182ce",
  frozen: "#90cdf4",
  flame: "#e53e3e"
};

// Select tower
function selectTower(type) {
  selectedTower = type;
  document.querySelectorAll("#shop button").forEach(b => b.style.background = "#2d3748");
  event.target.style.background = "#3182ce";
  updateDebugInfo();
}

// Draw everything
function draw() {
  // Clear
  ctx.fillStyle = "#0c0e1a";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw path (thicker for visibility)
  ctx.strokeStyle = "#4a5568";
  ctx.lineWidth = 42; // 40px path + 2px border
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for (let i = 1; i < path.length; i++) {
    ctx.lineTo(path[i].x, path[i].y);
  }
  ctx.stroke();
  
  // Draw debug zones
  drawDebugZones();
  
  // Draw existing towers
  towers.forEach(t => t.draw());
  
  // Draw mouse position
  if (selectedTower) {
    ctx.strokeStyle = "#d69e2e";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 25, 0, Math.PI * 2); // Show overlap check radius
    ctx.stroke();
    
    // Show placement preview
    ctx.fillStyle = typeColors[selectedTower] + "80";
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 14, 0, Math.PI * 2);
    ctx.fill();
  }
  
  requestAnimationFrame(draw);
}

// Draw debug zones
function drawDebugZones() {
  // Edge buffer zone (10px)
  ctx.fillStyle = "rgba(229, 62, 62, 0.2)";
  ctx.fillRect(0, 0, canvas.width, 10); // Top
  ctx.fillRect(0, 0, 10, canvas.height); // Left
  ctx.fillRect(0, canvas.height-10, canvas.width, 10); // Bottom
  ctx.fillRect(canvas.width-10, 0, 10, canvas.height); // Right
  
  // Path buffer zone (path width + 5px buffer)
  ctx.strokeStyle = "rgba(229, 62, 62, 0.3)";
  ctx.lineWidth = 50; // 40px path + 10px buffer (5px each side)
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for (let i = 1; i < path.length; i++) {
    ctx.lineTo(path[i].x, path[i].y);
  }
  ctx.stroke();
  
  // Tower overlap zones
  ctx.strokeStyle = "rgba(229, 62, 62, 0.4)";
  ctx.lineWidth = 2;
  towers.forEach(t => {
    ctx.beginPath();
    ctx.arc(t.x, t.y, 25, 0, Math.PI * 2); // 25px overlap radius
    ctx.stroke();
  });
  
  // Safe zones (green)
  ctx.fillStyle = "rgba(56, 161, 105, 0.1)";
  ctx.fillRect(10, 10, canvas.width-20, canvas.height-20);
  
  // Cut out path from safe zone
  ctx.globalCompositeOperation = "destination-out";
  ctx.beginPath();
  ctx.moveTo(path[0].x, 80-25);
  ctx.lineTo(path[1].x, 80-25);
  ctx.lineTo(path[1].x, 300+25);
  ctx.lineTo(path[2].x, 300+25);
  ctx.lineTo(path[2].x, 300+25);
  ctx.lineTo(path[3].x, 300+25);
  ctx.lineTo(path[3].x, 150-25);
  ctx.lineTo(path[4].x, 150-25);
  ctx.lineTo(path[4].x, 150-25);
  ctx.lineTo(path[5].x, 150-25);
  ctx.lineTo(path[5].x, 150+25);
  ctx.lineTo(path[4].x, 150+25);
  ctx.lineTo(path[4].x, 300+25);
  ctx.lineTo(path[3].x, 300+25);
  ctx.lineTo(path[3].x, 300-25);
  ctx.lineTo(path[2].x, 300-25);
  ctx.lineTo(path[2].x, 80-25);
  ctx.lineTo(path[1].x, 80-25);
  ctx.lineTo(path[1].x, 80+25);
  ctx.lineTo(path[0].x, 80+25);
  ctx.closePath();
  ctx.fill();
  ctx.globalCompositeOperation = "source-over";
}

// Mouse move
canvas.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
  updateDebugInfo();
});

// Click to place
canvas.addEventListener("click", e => {
  if (!selectedTower) {
    lastError = "No tower selected";
    updateDebugInfo();
    return;
  }
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // Check edge
  if (x < 10 || x > canvas.width - 10 || y < 10 || y > canvas.height - 10) {
    lastError = "Too close to edge";
    updateDebugInfo();
    return;
  }
  
  // Check path
  if (isOnPath(x, y)) {
    lastError = "On path";
    updateDebugInfo();
    return;
  }
  
  // Check tower overlap
  for (const t of towers) {
    if (Math.hypot(t.x - x, t.y - y) < 25) { // Was 32
      lastError = "Too close to tower";
      updateDebugInfo();
      return;
    }
  }
  
  // Success!
  towers.push(new Tower(x, y, selectedTower));
  lastError = "Tower placed!";
  updateDebugInfo();
});

// Update debug panel
function updateDebugInfo() {
  document.getElementById("mouse-pos").textContent = `(${Math.round(mouseX)}, ${Math.round(mouseY)})`;
  
  const onPath = isOnPath(mouseX, mouseY);
  document.getElementById("on-path").innerHTML = 
    onPath ? '<span class="debug-false">YES</span>' : '<span class="debug-true">NO</span>';
  
  const nearEdge = mouseX < 10 || mouseX > canvas.width-10 || mouseY < 10 || mouseY > canvas.height-10;
  document.getElementById("near-edge").innerHTML = 
    nearEdge ? '<span class="debug-false">YES</span>' : '<span class="debug-true">NO</span>';
  
  let nearTower = false;
  for (const t of towers) {
    if (Math.hypot(t.x - mouseX, t.y - mouseY) < 25) {
      nearTower = true;
      break;
    }
  }
  document.getElementById("near-tower").innerHTML = 
    nearTower ? '<span class="debug-false">YES</span>' : '<span class="debug-true">NO</span>';
  
  const canPlace = selectedTower && !onPath && !nearEdge && !nearTower;
  document.getElementById("can-place").innerHTML = 
    canPlace ? '<span class="debug-true">YES</span>' : '<span class="debug-false">NO</span>';
  
  document.getElementById("last-error").textContent = lastError;
}

// Initialize
draw();
updateDebugInfo();
selectTower('basic');
</script>
</body>
</html>
